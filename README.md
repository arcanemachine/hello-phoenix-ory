# OAuth Sandbox

This project provides a sandbox for working with various IAM applications (e.g. Ory, Keycloak), as well as small Elixir/Phoenix projects that demonstrate basic integration with these applications:

- `user_service` - Phoenix project for user management interface (Support Ory Kratos only)
- `oauth_sandbox` - OAuth machine-to-machine demo (Supports Ory Hydra, Keycloak)

This project contains a few different items:

- A Compose service that is used to run the Ory stack applications (Hydra, Kratos)
- An Elixir project (`oauth_sandbox`) that demonstrates a basic machine-to-machine auth workflow which validates OAuth access credentials (using Hydra or Keycloak)
- A Phoenix application (`user_service`) that demonstrates a basic user authentication workflow (using Kratos; currently has very limited functionality)

## Quickstart

> NOTE: All commands in this README should be run from the project root directory, unless otherwise specified.

### Start the auth server application(s)

- Run the correct command for your desired OAuth provider:
  - Ory: `docker compose -f ./compose.ory.yaml up`
  - Keycloak: `docker compose -f ./compose.keycloak.yaml up`

> TIP: The configuration for the Ory services is located in the directory `./volumes/config/`.

### Configure the Elixir client/server

The data generated by this script must be used in the `oauth_sandbox` Elixir project config.

#### Configure the Elixir project

- In the Elixir project, create a local runtime config file using the example template:

  - `cp ./oauth_sandbox/config/runtime.local.example.exs ./oauth_sandbox/config/runtime.local.exs`

- Run the Client Credentials grant script for the configured OAuth provider:
  - Ory:
    - Run `./ory-hydra-create-client-credentials-grant.sh`
      - You will need to run the script twice: Once to create credentials for the Elixir HTTP server, and once for our Elixir IEx "client".)
  - For Keycloak, you will use Keycloak's web UI to create and configure the OAuth client credentials (see the upcoming Keycloak section for more info)
  - Copy the generated OAuth client ID/secret pairs into your local runtime file.

### Run the Hydra machine-to-machine auth demo

#### Setup

- Navigate to the Elixir project directory: `cd ./oauth_sandbox`

- Fetch and install the Elixir dependencies: `mix deps.get`

- Start the Elixir client and HTTP server (they both run simultaneously in the same shell session): `iex -S mix`
  - The Elixir HTTP server runs in the background and responds to HTTP requests on the configured port (default: 8000).
  - The IEx "client" consists of the actions performed in the IEx shell.

> NOTE: Although the client and server are both running together, the real authentication/authorization process is still required for the server to send a successful response to the client.

#### Run the demo

- Perform the following actions in the client (IEx shell):

```elixir
# Sanity check: The unprotected URL route always works, even without a token
iex> OauthSandbox.send_request_to_unprotected_endpoint()
{:ok, %Req.Response{status: 200, body: "Hello, world!\n"}}

# Attempt to access the protected endpoint with an invalid token. (The request should return 401)
iex> OauthSandbox.send_request_to_protected_endpoint("invalid-token")
{:ok, %Req.Response{status: 401, body: "401 Unauthorized\n"}}

# Get a valid access token from the auth server
iex> {:ok, token} = OauthSandbox.fetch_access_token_for_elixir_client()
{:ok, "ory_at_0000000000000000000000000000000000000000000.0000000000000000000000000000000000000000000"}

# The protected endpoint can be accessed when using a valid token
iex> OauthSandbox.send_request_to_protected_endpoint(token)
{:ok, %Req.Response{status: 200, body: "401 Unauthorized\n"}}
```

That's it! This demonstrates how Ory Hydra can be used to authenticate and authorize machine-to-machine requests to a protected endpoint.

### Run the Keycloak machine-to-machine auth demo

#### Keycloak Client Credentials grant workflow

In the Keycloak UI:

- Login with admin credentials

- Create a realm if you have not already done so:

  - `Sidebar -> Manage realms -> Create realm` (e.g. "my-realm")

- Create a client (NOTE: This process creates OAuth 2.0 clients, and acts as a Client Credentials grant):

  - `Sidebar -> Clients -> Create client`
    - Enter the desired client ID, e.g. `service-a`, `service-b`.
      - NOTE: This ID will be used as the `client_id` when getting an access token for this client
    - The default options are mostly fine, with a couple exceptions:
      - Enable "Client authentication" (toggle)
      - Enable "Service accounts roles" (checkbox)
  - After creating the client, click the "Credentials" tab for the new client. Reveal the client secret, and copy it. (This is the value used as the "client_secret")

- Generate an access token for your new client:

#### Add scope and audience for the client and token

Scope:
  - Create a scope: - `Sidebar -> Client scopes -> Create client scope`
  - Name the scope (e.g. `service-b:read`)
  - Enable "Include in token scope" (toggle)
  - Assign the scope to the client:
    - `Sidebar -> Clients -> service-a -> Client scopes -> Add client scope`
    - Select the scope
    - Click `Add -> Default` (this will add the scope to all tokens by default; select "optional" to make the scope opt-in when fetching a new access token)

Audience:
  - To create an audience, we will create an "Audience" mapper for the scope we just created so that it applies to the desired client:
  - `Sidebar -> Client scopes -> service-b:read -> Mappers -> Configure a new mapper -> Audience`
  - Name the mapper (e.g. `service-b`)
  - Set the desired audience in the "Included Client audience" field (e.g. `service-b`)
  - Click the Save button

#### Run the demo

The process for running the Keycloak demo is the same as `Run the demo` in the Ory machine-to-machine auth demo in a previous section of this README.

### What validations are being performed?

The Elixir HTTP server performs the following validations on the access token that it receives:

- The token is valid and not expired (according to Hydra)
- The token comes from the expected client ID
- The token specifies the correct "audience" (`"service-b"`)
- The token specifies the correct "scope" (`"secrets:read"`)

### Digging deeper

For more information, see the module documentation for the `OauthSandbox` project in IEx:

```elixir
iex> h OauthSandbox
```

You may also check out the contents of the `oauth_sandbox` Elixir project to see how things work under the hood.

The project itself is quite simple. Most of the code is contained in the following files:

- `./oauth_sandbox/lib/oauth_sandbox.ex`
- `./oauth_sandbox/lib/oauth_sandbox/router.ex`

### Run the Kratos (user management) demo

> NOTE: This project is not currently very far along, and only implements a Kratos user registration workflow (no login).

- Start from the repo root directory.

- Ensure the Compose service has been started (the same one from before): `docker compose up`

- Navigate to the Phoenix user management project: `cd ./user_service/`

- Fetch and install the Elixir dependencies: `mix deps.get`

- Start the Phoenix server: `iex -S mix phx.server`

- In a web browser, navigate to `http://127.0.0.1:4000`.

  - NOTE: **Do not** use `localhost:4000`! For this project, Ory is configured for use with `127.0.0.1`, which is a different origin than `localhost`. Credentials cannot be shared between these two origins.

- Complete the registration form.

  - Any errors (e.g. short password, unavailable username) will be returned to the Phoenix server, and will be rendered in the template.

- After successful registration, the browser will display the text "Registration completed successfully".

- That's the whole demo so far.
